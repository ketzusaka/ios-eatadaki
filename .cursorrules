# Cursor Rules for Eatadaki iOS

## Architecture Documentation

Please refer to the architecture documentation at `docs/ARCHITECTURE.md` for detailed information about the app's architecture, state machine, and module structure.

## Key Architecture Points

- **State Machine Pattern**: The app uses three primary states: Initializing, Unauthenticated, and Authenticated
- **User Requirement**: All user data requires authentication - the app must have a logged-in user
- **Module Structure**: 
  - `Eatadaki` - App entry point and state machine
  - `EatadakiUI` - SwiftUI views
  - `EatadakiData` - Data persistence (GRDB) using Repository pattern
  - `EatadakiKit` - Shared utilities

## Code Style Guidelines

- Use SwiftUI for all UI
- Follow the state machine pattern for app flow
- Keep modules separated with clear dependencies
- Use GRDB for all database operations through `EatadakiRepository` protocol
- Implement `RealEatadakiRepository` as an actor for thread-safe database access using `DatabasePool`
- Use separate database migrators for each domain: `UserDatabaseMigrator`, `DeviceConfigDatabaseMigrator`, and `ExperiencesDatabaseMigrator`
- Repository methods use async/throws pattern
- Data models use UUID for identification (e.g., `Spot`)
- Ensure all user data operations require authentication
- **Create new files for new views**: Even if a view is a subview or component, it should have its own file. This improves code organization, reusability, and maintainability.
- **Database column naming**: Use camelCase for database column names to match Swift property names. Avoid CodingKeys - let GRDB's automatic Codable support handle the mapping directly.
- **Implicit shadowing**: When using optional binding with the same variable name, use implicit shadowing syntax: `if let variableName` instead of `if let variableName = variableName`. This reduces repetition and improves readability.
- **Trailing commas**: Always include trailing commas in multiline initializers, function calls, and collections (arrays, dictionaries, etc.). This makes diffs cleaner when adding new items - you only need to add a line instead of modifying an existing line. Example: `init(param1: value1, param2: value2,)` or `[item1, item2,]`.

## When Making Changes

- Consider the state machine when adding new features
- Ensure proper state transitions
- Maintain separation between UI, Data, and Business Logic layers

## Terminal Commands

- **Never use `head` or other output-limiting commands**: When running terminal commands, do not pipe output through `head`, `tail`, or similar commands. Show full output or use appropriate flags to control verbosity.
- Update architecture documentation if making significant structural changes

## Testing Guidelines

- **Test Helper Placement**: Place all helper methods (private functions used for test setup) at the end of test structs, after all test methods. Use a `// MARK: - Helpers` comment to separate them.
- **Date Usage in Tests**: Use `.now` instead of `Date()` for creating current date values in test code (e.g., `createdAt: .now`).
- **Never use sleep in tests**: **Never use `Task.sleep` or any timing-based delays in tests**. Tests must be deterministic.
  - ❌ **Incorrect**: `try? await Task.sleep(nanoseconds: 10_000_000); #expect(viewModel.stage == .initializing)`
- **Database Testing**: **Never perform assertions inside database read/write blocks**. Fetch data from the database and perform assertions outside the block. Running test macros (like `#expect` or `#require`) inside database blocks causes the test runner to crash instead of properly reporting failures.
  - ❌ **Incorrect**: `try db.read { database in let entry = try Row.fetchOne(...); #expect(entry != nil) }`
  - ✅ **Correct**: `let entry = try await db.read { database in try Row.fetchOne(...) }; #expect(entry != nil)`
- **Use Existing Fakes**: When writing tests, prefer using existing fake instances (e.g., `SpotRecord.peacePagoda`, `SpotRecord.kinokuniya`) instead of creating new test data inline. This improves consistency and reduces duplication. Existing fakes are typically defined in `*+Fakes.swift` files (e.g., `Spot+Fakes.swift`).

## Fake Implementation Guidelines

All `Fake[ProtocolName]` implementations (used for testing and previews) should follow this consistent pattern:

1. **Invocation Tracker**: For each protocol method, create a `private(set) var invocations[MethodName]` array that records all calls with their parameters as a tuple. Name the property using the method signature (e.g., `invocationsUrlForInAppropriateForCreate`).

2. **Stub Property**: For each protocol method, create a `var stub[MethodName]` closure property that can be overridden. The stub should have a default implementation that returns a successful result when possible (e.g., a dummy URL, empty array, or default value).

3. **Configure Init**: Use an initializer that takes an optional configure closure: `init(_ configure: (Fake[ProtocolName]) -> Void = { _ in })`. This allows easy configuration during initialization (e.g., `FakeFileSystemProvider { $0.stubUrlForInAppropriateForCreate = { ... } }`).

4. **Implementation**: In each protocol method implementation:
   - Append the call parameters to the invocation tracker
   - Call the stub closure and return its result

5. **DEBUG Only**: All Fake implementations must be wrapped in `#if DEBUG` compiler statements.

6. **AsyncSequence Stubs**: When stubbing methods that return `AsyncSequence`, use `FakeAsyncSequence` instead of creating custom empty sequence types. `FakeAsyncSequence` is available in `EatadakiData/Sources/Experiences/Fakes/FakeAsyncSequence.swift` and can be initialized with an empty array for empty sequences (e.g., `FakeAsyncSequence<[Element], Error>()`).

**Example Pattern:**
```swift
#if DEBUG
public class FakeFileSystemProvider: FileSystemProvider {
    public init(_ configure: (FakeFileSystemProvider) -> Void = { _ in }) {
        configure(self)
    }
    
    public private(set) var invocationsUrlForInAppropriateForCreate: [(directory: FileManager.SearchPathDirectory, domain: FileManager.SearchPathDomainMask, appropriateFor: URL?, create: Bool)] = []
    public var stubUrlForInAppropriateForCreate: ((FileManager.SearchPathDirectory, FileManager.SearchPathDomainMask, URL?, Bool) throws -> URL) = { directory, domain, url, shouldCreate in
        URL(fileURLWithPath: "/tmp/fake_application_support")
    }
    
    public func url(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, appropriateFor url: URL?, create shouldCreate: Bool) throws -> URL {
        invocationsUrlForInAppropriateForCreate.append((directory, domain, url, shouldCreate))
        return try stubUrlForInAppropriateForCreate(directory, domain, url, shouldCreate)
    }
}
#endif
```

## Development Workflow

- **Tuist Generation**: Always use `tuist generate --no-open` to prevent Xcode from automatically opening after generation. This avoids interrupting the user's workflow.
- **Command Output**: **NEVER use `head`, `tail`, `grep`, or any other output-filtering or limiting commands**. Always run commands directly without any piping or filtering. Show the full, unfiltered output as it's emitted.
- **Validating Changes**: When making code changes that should be validated:
  1. Generate the project: `tuist generate --no-open`
  2. Build and run the "All Unit Tests" scheme: `xcodebuild test -workspace ios-eatadaki/Eatadaki.xcworkspace -scheme "All Unit Tests" -destination 'platform=iOS Simulator,name=iPhone 17 Pro'`
  3. This ensures all unit tests pass before considering changes complete

## SwiftUI Preview Guidelines

- **Preview Syntax**: Use the latest `#preview` macro syntax for SwiftUI previews
- **DEBUG Compilation**: All previews must be wrapped in `#if DEBUG` compiler statements. This is required because previews may use types only available in debug builds (e.g., `PreviewProvider` types)
- **Theming**: Previews should use `ThemeManager.default` via `.environment(ThemeManager.default)` to ensure consistent theming in previews

