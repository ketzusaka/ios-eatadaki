# Cursor Rules for Eatadaki iOS

## Architecture Documentation

Please refer to the architecture documentation at `docs/ARCHITECTURE.md` for detailed information about the app's architecture, state machine, and module structure.

## Key Architecture Points

- **State Machine Pattern**: The app uses three primary states: Initializing, Unauthenticated, and Authenticated
- **User Requirement**: All user data requires authentication - the app must have a logged-in user
- **Module Structure**: 
  - `Eatadaki` - App entry point and state machine
  - `EatadakiUI` - SwiftUI views
  - `EatadakiData` - Data persistence (GRDB) using Repository pattern
  - `EatadakiKit` - Shared utilities

## Code Style Guidelines

- Use SwiftUI for all UI
- Follow the state machine pattern for app flow
- Keep modules separated with clear dependencies
- Use GRDB for all database operations through `EatadakiRepository` protocol
- Implement `RealEatadakiRepository` as an actor for thread-safe database access using `DatabasePool`
- Use separate database migrators for each domain: `UserDatabaseMigrator`, `DeviceConfigDatabaseMigrator`, and `ExperiencesDatabaseMigrator`
- Repository methods use async/throws pattern
- Data models use UUID for identification (e.g., `Spot`)
- Ensure all user data operations require authentication
- **Create new files for new views**: Even if a view is a subview or component, it should have its own file. This improves code organization, reusability, and maintainability.
- **Database column naming**: Use camelCase for database column names to match Swift property names. Avoid CodingKeys - let GRDB's automatic Codable support handle the mapping directly.
- **Implicit shadowing**: When using optional binding with the same variable name, use implicit shadowing syntax: `if let variableName` instead of `if let variableName = variableName`. This reduces repetition and improves readability.
- **Trailing commas**: Always include trailing commas in multiline initializers, function calls, and collections (arrays, dictionaries, etc.). This makes diffs cleaner when adding new items - you only need to add a line instead of modifying an existing line. Example: `init(param1: value1, param2: value2,)` or `[item1, item2,]`.

## When Making Changes

- Consider the state machine when adding new features
- Ensure proper state transitions
- Maintain separation between UI, Data, and Business Logic layers
- Update architecture documentation if making significant structural changes

## Testing Guidelines

- **Test Helper Placement**: Place all helper methods (private functions used for test setup) at the end of test structs, after all test methods. Use a `// MARK: - Helpers` comment to separate them.
- **Date Usage in Tests**: Use `.now` instead of `Date()` for creating current date values in test code (e.g., `createdAt: .now`).
- **Database Testing**: **Never perform assertions inside database read/write blocks**. Fetch data from the database and perform assertions outside the block. Running test macros (like `#expect` or `#require`) inside database blocks causes the test runner to crash instead of properly reporting failures.
  - ❌ **Incorrect**: `try db.read { database in let entry = try Row.fetchOne(...); #expect(entry != nil) }`
  - ✅ **Correct**: `let entry = try await db.read { database in try Row.fetchOne(...) }; #expect(entry != nil)`

## Fake Implementation Guidelines

All `Fake[ProtocolName]` implementations (used for testing and previews) should follow this consistent pattern:

1. **Invocation Tracker**: For each protocol method, create a `private(set) var invocations[MethodName]` array that records all calls with their parameters as a tuple. Name the property using the method signature (e.g., `invocationsUrlForInAppropriateForCreate`).

2. **Stub Property**: For each protocol method, create a `var stub[MethodName]` closure property that can be overridden. The stub should have a default implementation that returns a successful result when possible (e.g., a dummy URL, empty array, or default value).

3. **Configure Init**: Use an initializer that takes an optional configure closure: `init(_ configure: (Fake[ProtocolName]) -> Void = { _ in })`. This allows easy configuration during initialization (e.g., `FakeFileSystemProvider { $0.stubUrlForInAppropriateForCreate = { ... } }`).

4. **Implementation**: In each protocol method implementation:
   - Append the call parameters to the invocation tracker
   - Call the stub closure and return its result

5. **DEBUG Only**: All Fake implementations must be wrapped in `#if DEBUG` compiler statements.

**Example Pattern:**
```swift
#if DEBUG
public class FakeFileSystemProvider: FileSystemProvider {
    public init(_ configure: (FakeFileSystemProvider) -> Void = { _ in }) {
        configure(self)
    }
    
    public private(set) var invocationsUrlForInAppropriateForCreate: [(directory: FileManager.SearchPathDirectory, domain: FileManager.SearchPathDomainMask, appropriateFor: URL?, create: Bool)] = []
    public var stubUrlForInAppropriateForCreate: ((FileManager.SearchPathDirectory, FileManager.SearchPathDomainMask, URL?, Bool) throws -> URL) = { directory, domain, url, shouldCreate in
        URL(fileURLWithPath: "/tmp/fake_application_support")
    }
    
    public func url(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, appropriateFor url: URL?, create shouldCreate: Bool) throws -> URL {
        invocationsUrlForInAppropriateForCreate.append((directory, domain, url, shouldCreate))
        return try stubUrlForInAppropriateForCreate(directory, domain, url, shouldCreate)
    }
}
#endif
```

## Development Workflow

- **Tuist Generation**: Always use `tuist generate --no-open` to prevent Xcode from automatically opening after generation. This avoids interrupting the user's workflow.
- **Command Output**: Do not use `tail` or `head` with commands. These commands prevent seeing the full command output as it's emitted. Always run commands directly without piping to `tail` or `head`.

## SwiftUI Preview Guidelines

- **Preview Syntax**: Use the latest `#preview` macro syntax for SwiftUI previews
- **DEBUG Compilation**: All previews must be wrapped in `#if DEBUG` compiler statements. This is required because previews may use types only available in debug builds (e.g., `PreviewProvider` types)
- **Theming**: Previews should use `ThemeManager.default` via `.environment(ThemeManager.default)` to ensure consistent theming in previews

